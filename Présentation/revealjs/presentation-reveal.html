<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoChallenge Tracker ‚Äî Soutenance</title>
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/league.css" id="theme" />
    <style>
        .reveal section h1,
        .reveal section h2 {
            text-transform: none;
        }

        .reveal .slides {
            font-size: 30px;
        }

        .reveal ul {
            line-height: 1.3;
        }

        .logo-placeholder {
            width: 140px;
            height: 140px;
            border: 2px dashed #999;
            border-radius: 12px;
            display: inline-block;
            line-height: 140px;
            text-align: center;
            color: #999;
            font-size: 20px;
        }

        .credits {
            font-size: 22px;
            color: #555;
            margin-top: 1rem;
        }
    </style>

    <link rel="stylesheet" href="presentation-reveal.css" />
</head>

<body>
    <div class="reveal">
        <div class="brand-header">
            <div class="brand-logo"></div>
            <div class="brand-name">GeoChallenge Tracker</div>
        </div>
        <div class="brand-footer"></div>
        <div class="slides">

            <section>
                <h1><span class="logo-wrapper"><img class="logo" src="assets/logo-cropped.svg"
                            alt="" /></span>GeoChallenge
                    Tracker</h1>
                <div class="credits">
                    <div>Jean Ceugniet</div>
                    <div>Titre Concepteur D√©veloppeur d'Applications, 28 octobre 2025</div>
                </div>
                <aside class="notes">
                    Identit√© produit<br>
                    Contexte
                </aside>
            </section>

            <section>
                <h2>Pr√©sentation entreprise / client</h2>
                <ul>
                    <li class="fragment diapo__item">Communaut√© : <span class="diapo__item__content">g√©ocacheurs</span>
                    </li>
                    <li class="fragment diapo__item">Client : <span class="diapo__item__content">passionn√©s de
                            challenges</span></li>
                    <li class="fragment diapo__item">Pool tests : <span class="diapo__item__content">12 testeurs,
                            profils vari√©s</span></li>
                </ul>
                <aside class="notes">
                    Insister sur le jeu dans le jeu<br>
                    Expliquer la complexit√© de suivi : dur√©e et volume
                </aside>
            </section>

            <section>
                <h2>Existant, besoins, contraintes, livrables</h2>
                <ul>
                    <li class="fragment diapo__item">Existant : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_03_existant">forces,
                            faiblesses</a></span></li>
                    <li class="fragment diapo__item">Besoin : <span class="diapo__item__content">ergonomie,
                            fonctionnalit√©s, performance</span></li>
                    <li class="fragment diapo__item">Contraintes : <span class="diapo__item__content">deadline
                            10/10/2025, mobile-first, limites APIs externes, plateforme de test</span></li>
                    <li class="fragment diapo__item">Livrables : <span class="diapo__item__content">dossier projet +
                            annexes, application web, documentation technique</span></li>
                </ul>
                <aside class="notes">
                    Existant : Force exhaustivit√© / Faiblesse densit√© d'information / <br>
                    Contraintes : importance du respect des limites APIs externes
                </aside>
                <dialog class="dialog" id="dialog_03_existant">
                    <h3 class="dialog__title">Project GC</h3>
                    <div class="dialog__content">
                        <img src="assets/03/projectgc.png" alt="ProjectGC, dashboard" />
                    </div>
                </dialog>
            </section>

            <section>
                <h2>Gestion de projet</h2>
                <ul>
                    <li class="fragment diapo__item">Agile solo : <span class="diapo__item__content">sprints 1 semaine
                            (x10), MoSCoW, revues</span></li>
                    <li class="fragment diapo__item">Suivi : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_04_github">GitHub Projects
                            (kanban)</a>, issues, milestones</span></li>
                    <li class="fragment diapo__item">Stack : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_04_docker">Docker</a>, Python 3.11,
                            FastAPI, MongoDB, Vue.js</span></li>
                    <li class="fragment diapo__item">Qualit√© : <span class="diapo__item__content">CI/CD/CC, coverage,
                            P95</span></li>
                </ul>
                <aside class="notes">
                    MoSCoW : Must, Should, Could, Won't<br>
                    GitHub Projects : screenshots github projects, focaliser sur la diff√©rence <a
                        href="assets/04/github-roadmap.png">roadmap</a> / <a
                        href="assets/04/github-kanban.png">kanban</a><br>
                    Docker : <a href="assets/04/docker-compose.yml.txt">compose multi-services</a>
                </aside>
                <dialog class="dialog" id="dialog_04_github">
                    <h3 class="dialog__title">Github</h3>
                    <div class="dialog__content">
                        <h4>Vue roadmap</h4>
                        <img src="assets/04/github-roadmap.png" alt="Github, roadmap" />
                        <h4>Vue Kanban</h4>
                        <img src="assets/04/github-kanban.png" alt="Github, kanban" />        
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_04_docker">
                    <h3 class="dialog__title">Docker Compose</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
# ---------------------------
# üß± docker-compose.yml (optimis√© dev/prod)
# ---------------------------
services:
    backend:
    build:
        context: ./backend
        dockerfile: Dockerfile
    container_name: geo-backend
    ports:
        - "8000:8000"
    env_file:
        - .env
    environment:
        - MONGODB_USER=${MONGODB_USER}
        - MONGODB_PASSWORD=${MONGODB_PASSWORD}
        - MONGODB_URI_TPL=${MONGODB_URI_TPL}
        - MONGODB_DB=${MONGODB_DB}
        - JWT_SECRET_KEY=${JWT_SECRET_KEY}
        - SMTP_HOST=${SMTP_HOST}
        - SMTP_PORT=${SMTP_PORT}
        - BACKUP_DIR=/backups
    depends_on:
        - maildev
    volumes:
        - ./backend:/app
        - ./backups:/backups
        - ./backend/uploads:/app/uploads
        - ./backend/data/samples:/app/data/samples
        - ./.env:/app/.env
    restart: unless-stopped

    maildev:
    container_name: geo-maildev
    image: maildev/maildev
    ports:
        - "1080:1080"
        - "1025:1025"
    restart: unless-stopped

    # --- Frontend unifi√© avec variable d'environnement ---
    frontend:
    build:
        context: ./frontend
        dockerfile: Dockerfile
        target: ${DOCKER_TARGET:-dev}
        args:
        VITE_API_URL: ${VITE_API_URL:-/api}
        VITE_TILE_URL: ${VITE_TILE_URL:-/tiles/{z}/{x}/{y}.png}
    container_name: geo-frontend
    env_file:
        - .env
    environment:
        - CHOKIDAR_USEPOLLING=${CHOKIDAR_USEPOLLING:-true}
        - VITE_API_URL=${VITE_API_URL:-/api}
        - VITE_TILE_URL=${VITE_TILE_URL:-/tiles/{z}/{x}/{y}.png}
    depends_on:
        - backend
        - tiles
    ports:
        - "${FRONTEND_PORT:-5173}:${FRONTEND_INTERNAL_PORT:-5173}"
    volumes:
        - ./frontend:/app
        - /app/node_modules
    restart: unless-stopped

    # --- Service tiles (commun dev/prod) ---
    tiles:
    image: nginx:1.25-alpine
    container_name: geo-tiles
    restart: unless-stopped
    command: |
        sh -c "
        rm -f /etc/nginx/conf.d/default.conf &&
        mkdir -p /var/log/nginx /var/cache/nginx/tiles_cache &&
        nginx -g 'daemon off;'
        "
    volumes:
        # Configuration optimis√©e
        - ./ops/nginx/tiles.conf:/etc/nginx/conf.d/tiles.conf:ro
        # Sant√© + assets locaux
        - ./ops/nginx/www:/var/www:ro
        # Cache persistant avec permissions
        - tiles_cache:/var/cache/nginx/tiles_cache
        # Logs pour debug
        - tiles_logs:/var/log/nginx
    ports:
        - "8080:80"
    # Limite m√©moire pour √©viter les fuites
    deploy:
        resources:
        limits:
            memory: 512M
        reservations:
            memory: 256M
    # Sant√© du conteneur
    healthcheck:
        test: ["CMD-SHELL", "wget -q -O /dev/null http://127.0.0.1/tiles/_health.png || exit 1"]
        interval: 30s
        timeout: 3s
        retries: 3
        start_period: 10s

volumes:
    tiles_cache:
    driver: local
    tiles_logs:
    driver: local

# --- Commandes rapides ---
# D√©veloppement: docker-compose --profile dev up -d
# Production:    docker-compose --profile prod up -d
# Les deux:      docker-compose --profile dev --profile prod up -d
                            </pre>
                        </code>
                    </div>
                </dialog>
            </section>

            <section>
                <h2>Architecture logicielle</h2>
                <ul>
                    <li class="fragment diapo__item">3-tiers :<br>
                        <ul class="diapo__item__content">
                            <li><img src="assets/05/logo-vuejs.svg" alt="">Vue.js</li>
                            <li><img src="assets/05/logo-fastapi.svg" alt="">FastAPI</li>
                            <li><img src="assets/05/logo-mongodb.svg" alt="">MongoDB</li>
                        </ul>
                    </li>
                    <li class="fragment diapo__item">S√©paration claire : <span class="diapo__item__content"><a href="#dialog_archi_details"
                                class="dialog_toggler">routes /
                                services / mod√®les</a></span></li>
                    <li class="fragment diapo__item">Encapsulation des d√©pendances externes : <span
                            class="diapo__item__content">altim√©trie</span></li>
                </ul>

                <dialog class="dialog" id="dialog_archi_details">
                    <h3 class="dialog__title">Organisation du projet et conteneurs Docker</h3>

                    <div class="dialog__content grid_6 architecture">
                            <div class="docker frontend">
                                <div class="title">üíª Frontend</div>
                                <pre><code>frontend/
        ‚îú‚îÄ‚îÄ üìÇ public/
        ‚îú‚îÄ‚îÄ üì¶ src/
        ‚îÇ   ‚îú‚îÄ‚îÄ üß© components/
        ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ pages/
        ‚îÇ   ‚îú‚îÄ‚îÄ üß≠ router/
        ‚îÇ   ‚îî‚îÄ‚îÄ üìö store/
        ‚îî‚îÄ‚îÄ üß™ tests/
                        </code></pre>
                            </div>

                            <div class="docker backend">
                                <div class="title">üñ•Ô∏è Backend</div>
                                <pre><code>backend/
        ‚îú‚îÄ‚îÄ üì¶ app/
        ‚îÇ   ‚îú‚îÄ‚îÄ üîó api/routes/
        ‚îÇ   ‚îú‚îÄ‚îÄ üîß services/
        ‚îÇ   ‚îú‚îÄ‚îÄ üß± models/
        ‚îÇ   ‚îî‚îÄ‚îÄ üíæ db/
        ‚îú‚îÄ‚îÄ üß™ tests/
        ‚îî‚îÄ‚îÄ üì§ uploads/gpx/
                        </code></pre>
                            </div>

                            <div class="docker db">
                                <div class="title">üóÑÔ∏è Database</div>
                                <pre><code>
        ‚îú‚îÄ‚îÄ üìÅ collections/
        ‚îÇ   ‚îú‚îÄ‚îÄ caches
        ‚îÇ   ‚îú‚îÄ‚îÄ challenges
        ‚îÇ   ‚îú‚îÄ‚îÄ userChallenges
        ‚îÇ   ‚îî‚îÄ‚îÄ userChallengesTasks
                        </code></pre>
                            </div>

                            <div class="docker ops">
                                <div class="title">üõ†Ô∏è Ops</div>
                                <pre><code>ops/
        ‚îú‚îÄ‚îÄ üöÄ deploy/
        ‚îî‚îÄ‚îÄ üåç nginx/www/tiles/
                        </code></pre>
                            </div>

                            <div class="docker global">
                                <div class="title">üåê Global</div>
                                <pre><code>/
        ‚îú‚îÄ‚îÄ üíæ backups/
        ‚îÇ   ‚îú‚îÄ‚îÄ üßπ db_cleanup/
        ‚îÇ   ‚îî‚îÄ‚îÄ üì¶ full_backup/
        ‚îî‚îÄ‚îÄ üì§ uploads/gpx/
                        </code></pre>
                            </div>
                        </div>
                </dialog>

                <aside class="notes">
                    3-tiers : se pr√©parer aux questions sur le choix de la stack<br>
                    S√©paration : <a href="assets/05/folder.png">structure dossiers</a><br>
                    Encapsulation : abstraction == possibilit√© de changement de provider
                </aside>
            </section>


            <section>
                <h2>Maquettes &amp; encha√Ænement</h2>
                <ul>
                    <li class="fragment diapo__item">Screenshots : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_06_maquettes">Accueil / Carte / Liste challenges</a></span></li>
                    <li class="fragment diapo__item">Charte : <span class="diapo__item__content">mobile-first, sobre,
                            lisible, performances</span></li>
                </ul>
                <dialog class="dialog" id="dialog_06_maquettes">
                    <h3 class="dialog__title">Maquettes &amp √©crans</h3>

                    <div class="dialog__content">
                        <h4>Accueil</h4>
                        <img src="assets/06/homepage-logged-full-split.png" alt="Accueil" />
                        <h4>Liste des challenges</h4>
                        <img src="assets/06/challenges-list.png" alt="Liste des challenges" />
                        <h4>Carte interactive</h4>
                        <img src="assets/06/interactive-map-mobile.png" alt="Map" />
                    </div>
                </dialog>
                <aside class="notes">
                    Screenshots : sobri√©t√© graphique assum√©e, on est sur un outil<br>
                    Encha√Ænements : <a href="assets/06/diagramme_enchainements.svg">diagramme des encha√Ænements</a>
                    Charte : <a
                        href="https://www.figma.com/proto/ba8qCI2QTFiJi3dkZAghaZ/Geocaching?node-id=0-1&t=09PPhu9lbqOrJfQR-1">lien
                        figma direct</a>
                </aside>

            </section>

            <section>
                <h2>Mod√®le de donn√©es</h2>
                <ul>
                    <li class="fragment diapo__item">Diagramme E/A : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_07_ea_simple">simplifi√©</a> / <a class="dialog_toggler" href="#dialog_07_mcd">conceptuel</a> / <a class="dialog_toggler" href="#dialog_07_mpd">physique</a></span></li>
                    <li class="fragment diapo__item">Indexes : <span class="diapo__item__content">requ√™tes g√©ospatiales
                            (geoNear, 2d sphere)</span></li>
                    <li class="fragment diapo__item">Collections cl√©s : <span class="diapo__item__content">caches /
                            user_challenges / progress</span></li>
                </ul>
                <dialog class="dialog" id="dialog_07_ea_simple">
                    <h3 class="dialog__title">Diagramme Entit√©s-Associations simplifi√©</h3>
                    <div class="dialog__content">
                        <img src="assets/07/diagramme_ea.svg" alt="Diagramme E/A" width="1568" height="570" />
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_07_mcd">
                    <h3 class="dialog__title">Mod√®le conceptuel de donn√©es</h3>
                    <div class="dialog__content">
                        <img src="assets/07/mcd.svg" alt="MCD" width="1568" height="1646" />
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_07_mpd">
                    <h3 class="dialog__title">Mod√®le physique de donn√©es</h3>
                    <div class="dialog__content">
                        <img src="assets/07/mpd.svg" alt="MPD" width="1568" height="1108" />
                    </div>
                </dialog>
                <aside class="notes">
                    Diagramme : <a href="assets/07/mcd.svg">MCD</a> / <a href="assets/07/mpd.svg">MPD</a><br>
                    Indexes : <a href="assets/07/seed_indexes.py.txt">seed_indexes</a>, expliquer l'importance de l'index
                    2d sphere<br>
                    Collections : caches / user challenges / progress. Si on montre des collections d√©normalis√©es, on le
                    dit ouvertement
                </aside>
            </section>

            <section>
                <h2>Cas d‚Äôutilisation</h2>
                <ul>
                    <li class="fragment diapo__item">Diagramme des cas : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_08_cas_utilisation">liste des cas</a></span></li>
                    <li class="fragment diapo__item">Parcours : <span class="diapo__item__content">importer GPX => g√©rer
                            challenges => suivre progression => identifier targets</span></li>
                </ul>
                <dialog class="dialog" id="dialog_08_cas_utilisation">
                    <h3 class="dialog__title">Diagramme des cas d'utilisation</h3>
                    <div class="dialog__content">
                        <img src="assets/08/diagramme_de_cas.svg" alt="Diagramme des cas" width="754" height="1510" />
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/08/diagramme-cas.svg">Diagramme des cas</a><br>
                    <a href="assets/08/parcours-import.svg">Parcours import GPX</a>
                </aside>
            </section>

            <section>
                <h2>Diagrammes de s√©quence</h2>
                <ul>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_09_importgpx">Import GPX</a></li>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_09_progression">Calcul de progression</a></li>
                </ul>
                <dialog class="dialog" id="dialog_09_importgpx">
                    <h3 class="dialog__title">Diagramme de s√©quence : Import GPX</h3>
                    <div class="dialog__content">
                        <img src="assets/09/diagramme_sequence_import_gpx.svg" alt="Import GPX" width="1568" height="1130" />
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_09_progression">
                    <h3 class="dialog__title">Diagramme de s√©quence : Calcul de progression</h3>
                    <div class="dialog__content">
                        <img src="assets/09/diagramme_sequence_progression.svg" alt="Calcul de progression" width="1568" height="1454" />
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/09/diagramme-sequence.svg">Diagramme de s√©quence</a><br>
                    <a href="assets/09/evaluation-taches.png">√âvaluation t√¢ches</a>
                </aside>
            </section>

            <section>
                <h2>UI ‚Äî Carte interactive</h2>
                <ul>
                    <li class="fragment diapo__item">Screenshots <a class="dialog_toggler" href="#dialog_10_map_desktop">desktop</a> + <a class="dialog_toggler" href="#dialog_10_map_mobile">mobile</a></li>
                    <li class="fragment diapo__item">Composant MapBase.vue : <span class="diapo__item__content"><a class="dialog_toggler" href="#dialog_10_mapbase">Leaflet,
                            clustering, tile caching</a></span></li>
                    <li class="fragment diapo__item">Performance &amp; green computing</li>
                </ul>
                <dialog class="dialog" id="dialog_10_map_desktop">
                    <h3 class="dialog__title">Carte interactive : desktop</h3>
                    <div class="dialog__content">
                        <img src="assets/10/map_desktop.png" alt="Map desktop" width="1920" height="936" />
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_10_map_mobile">
                    <h3 class="dialog__title">Carte interactive : mobile</h3>
                    <div class="dialog__content">
                        <img src="assets/10/map_mobile.png" alt="Map mobile" width="360" height="800" />
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_10_mapbase">
                    <h3 class="dialog__title">MapBase.vue</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
                              &lt;template&gt;
                                &lt;!-- le parent de MapBase doit &ecirc;tre positionn&eacute; (relative/absolute) ; ici on remplit --&gt;
                                &lt;div                                  
                                  ref=&quot;el&quot;
                                  class=&quot;absolute inset-0&quot;
                                /&gt;
                              &lt;/template&gt;
                              
                              &lt;script setup lang=&quot;ts&quot;&gt;
                              import { ref, onMounted, onBeforeUnmount, computed, watch, defineEmits, defineExpose } from &quot;vue&quot;;
                              import L from 'leaflet'
                              import { installCrosshairPicker, type CrosshairPicker } from &quot;./crosshairPicker&quot;;
                              import { useAuthStore } from '@/store/auth'
                              
                              type LatLng = [number, number] // [lat, lng]
                              const props = defineProps&lt;{ center?: LatLng; zoom?: number; attribution?: string }&gt;()
                              
                              const emit = defineEmits&lt;{
                                  (e: &quot;ready&quot;, map: L.Map): void;
                                  (e: &quot;pick&quot;, payload: { lat: number; lng: number }): void;
                                  (e: &quot;centerChanged&quot;, payload: { lat: number; lng: number; coords: string }): void; // &larr; AJOUT ICI
                              }&gt;();
                              const el = ref&lt;HTMLDivElement | null&gt;(null)
                              let map: L.Map | null = null
                              let picker: CrosshairPicker | null = null;
                              const auth = useAuthStore()
                              
                              const fallbackCenter: LatLng = [46.6, 2.6]  // France approx
                              const initialZoom = computed(() =&gt; props.zoom ?? 6)
                              const attribution = computed(
                                  () =&gt; props.attribution ?? '&copy; OpenStreetMap contributors'
                              )
                              
                              // Fonction pour formater les coordonn&eacute;es
                              function formatCoords(lat: number, lng: number): string {
                                  const latDir = lat &gt;= 0 ? 'N' : 'S'
                                  const lngDir = lng &gt;= 0 ? 'E' : 'W'
                              
                                  const latDeg = Math.floor(Math.abs(lat))
                                  const latMin = ((Math.abs(lat) - latDeg) * 60).toFixed(3)
                              
                                  const lngDeg = Math.floor(Math.abs(lng))
                                  const lngMin = ((Math.abs(lng) - lngDeg) * 60).toFixed(3)
                              
                                  return `${latDir}${latDeg} ${latMin} ${lngDir}${lngDeg} ${lngMin}`
                              }
                              
                              // Fonction pour &eacute;mettre le centre actuel
                              function emitCurrentCenter() {
                                  if (!map) return
                              
                                  const center = map.getCenter()
                                  const coords = formatCoords(center.lat, center.lng)
                              
                                  emit('centerChanged', {
                                      lat: center.lat,
                                      lng: center.lng,
                                      coords
                                  })
                              }
                              
                              function currentCenter(): LatLng {
                                  if (props.center) return props.center
                                  const loc = auth.user?.location
                                  console.log(&quot;loc&quot;, loc)
                                  if (loc &amp;&amp; Number.isFinite(loc.lat) &amp;&amp; Number.isFinite(loc.lon)) {
                                      console.log(&quot;loc found&quot;, loc.lat, loc.lon)
                                      return [loc.lat, loc.lon]
                                  }
                                  return fallbackCenter
                              }
                              
                              function tileUrl() {
                                  const retina = L.Browser.retina ? '@2x' : ''
                                  return `/tiles/{z}/{x}/{y}${retina}.png`
                              }
                              
                              // --- listener resize d&eacute;fini au niveau module pour pouvoir le retirer proprement ---
                              const onResize = () =&gt; map?.invalidateSize(true);
                              
                              function init() {
                                  if (!el.value) return;
                                  map = L.map(el.value, { zoomControl: true });
                                  L.tileLayer(tileUrl(), { maxZoom: 19, attribution: attribution.value }).addTo(map);
                                  map.setView(currentCenter(), initialZoom.value);
                                  // (si tu n&rsquo;en as pas besoin, tu peux retirer cet emit de click)
                                  // map.on(&quot;click&quot;, (ev) =&gt; emit(&quot;click&quot; as any, ev));
                              
                                  emit(&quot;ready&quot;, map);              // ‚úÖ on garde CE emit
                                  setTimeout(() =&gt; map?.invalidateSize(true), 0);
                              }
                              
                              // remplace ta logique de watch/recenter par ceci :
                              
                              let recentered = false
                              
                              function tryRecenterOnce() {
                                  if (!map || recentered) return
                                  // priorit&eacute; au prop center, sinon user.location, sinon rien
                                  const fromProp = props.center
                                  const fromUser = auth.user?.location
                                  const target =
                                      (fromProp &amp;&amp; Number.isFinite(fromProp[0]) &amp;&amp; Number.isFinite(fromProp[1]))
                                          ? fromProp
                                          : (fromUser &amp;&amp; Number.isFinite(fromUser.lat) &amp;&amp; Number.isFinite(fromUser.lon))
                                              ? [fromUser.lat, fromUser.lon] as [number, number]
                                              : null
                              
                                  if (target) {
                                      map.setView(target, initialZoom.value)
                                      recentered = true
                                      emitCurrentCenter()
                                  }
                              }
                              
                              onMounted(() =&gt; {
                                  init()
                                  window.addEventListener(&quot;resize&quot;, onResize);
                              
                                  // Crosshair picker install&eacute; mais inactif tant qu&rsquo;on ne l&rsquo;active pas
                                  if (map) {
                                      picker = installCrosshairPicker(map, (ll) =&gt; {
                                          emit(&quot;pick&quot;, { lat: ll.lat, lng: ll.lng });
                                      });
                              
                                      // &Eacute;couter les mouvements de carte
                                      map.on('moveend', () =&gt; {
                                          emitCurrentCenter()
                                      })
                                  }
                                  
                                  onBeforeUnmount(() =&gt; window.removeEventListener('resize', onResize))
                                  // ‚ûï Ajout non intrusif du picker (d&eacute;sactiv&eacute; par d&eacute;faut)
                              
                                  tryRecenterOnce()
                              })
                              
                              onBeforeUnmount(() =&gt; {
                                  window.removeEventListener(&quot;resize&quot;, onResize);
                                  if (picker) picker.destroy();
                                  if (map) {
                                      map.remove();
                                      map = null;
                                  }
                              });
                              
                              // ‚ûï Exposer des m&eacute;thodes au parent (pour d&eacute;clencher depuis un bouton)
                              function enablePick() {
                                  console.log(&quot;[MapBase] enablePick()&quot;);
                                  console.log(&quot;[MapBase] picker is&quot;, picker);
                              
                                  picker?.enable();
                              }
                              function disablePick() {
                                  console.log(&quot;[MapBase] disablePick()&quot;);
                                  picker?.disable();
                              }
                              defineExpose({ getMap: () =&gt; map, enablePick, disablePick });
                              
                              // üëâ r&eacute;agir si le center prop change (par ex. via une recherche)
                              watch(() =&gt; props.center, () =&gt; {
                                  // on autorise un re-center si c&rsquo;est un center &ldquo;externe&rdquo;
                                  recentered = false
                                  tryRecenterOnce()
                              })
                              
                              // üëâ r&eacute;agir si la localisation utilisateur arrive/apr&egrave;s-coup
                              watch(() =&gt; auth.user?.location, () =&gt; {
                                  // seulement si on n&rsquo;a pas encore recadr&eacute; via user
                                  tryRecenterOnce()
                              })
                              &lt;/script&gt;
                            </pre>

                        </code>>
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/10/map_mobile.png">Mobile</a><br>
                    <a href="assets/10/map_desktop.png">Desktop</a><br>
                    <a href="assets/10/tiles.conf.txt">Tiles caching</a>
                </aside>
            </section>

            <section>
                <h2>UI ‚Äî Liste challenges</h2>
                <ul>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_11_challenges_list">Filtrage, pagination, statuts, barre d‚Äôactions</a></li>
                    <li class="fragment diapo__item">Composant Vue</li>
                </ul>
                <dialog class="dialog" id="dialog_11_challenges_list">
                    <h3 class="dialog__title">User challenges : liste</h3>
                    <div class="dialog__content">
                        <img src="assets/11/user_challenges_list.png" alt="User challenges list" width="360" height="800" />
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/11/challenges_list.vue.txt">Liste challenges</a><br>
                    Seul store Pinia actuellement : auth
                </aside>
            </section>

            <section>
                <h2>UI ‚Äî D√©tails challenge</h2>
                <ul>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_12_challenge_details">Structure de page</a></li>
                    <li class="fragment diapo__item">Description sanitis√©e (DOMPurify)</li>
                    <li class="fragment diapo__item">Notes &amp; override</li>
                    <li class="fragment diapo__item">Progression agr√©g√©e + t√¢ches</li>
                </ul>
                <dialog class="dialog" id="dialog_12_challenge_details">
                    <h3 class="dialog__title">User challenge : details</h3>
                    <div class="dialog__content">
                        <img src="assets/12/user_challenge_details.png" alt="User challenge details" width="726" height="1197" />
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/12/challenge_details.vue.txt">Challenge, d√©tails</a>
                </aside>
            </section>

            <section>
                <h2>Composant m√©tier ‚Äî Parser GPX</h2>
                <ul>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_13_gpx_parser">GPXCacheParser.py ‚Äî multi-namespaces (‚â•5 standards)</a></li>
                    <li class="fragment diapo__item">Extraction : <span class="diapo__item__content">attributs,
                            m√©tadonn√©es, validation stricte</span></li>
                </ul>
                <dialog class="dialog" id="dialog_13_gpx_parser">
                    <h3 class="dialog__title">GPX Parser : code</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
# backend/app/services/parsers/GPXCacheParser.py
# Parse un fichier GPX (ouvert depuis un chemin) pour extraire des g√©ocaches structur√©es (m√©tadonn√©es, attributs).

import html
from pathlib import Path
from typing import Any

from lxml import etree

from app.services.parsers.HTMLSanitizer import HTMLSanitizer


class GPXCacheParser:
    """Parseur GPX de g√©ocaches.

    Description:
        Lit un fichier GPX (sch√©mas `gpx`, `groundspeak`, `gsak`) et en extrait une
        liste de caches pr√™tes pour l‚Äôimport : code GC, titre, coordonn√©es, type,
        taille, propri√©taire, D/T, pays/√©tat, description HTML (sanitis√©e), favoris,
        notes, dates (placement / found), attributs, etc.

    Attributes:
        gpx_file (Path): Chemin du fichier GPX.
        namespaces (dict): Pr√©fixes d‚Äôespaces de noms XML utilis√©s pour les requ√™tes XPath.
        caches (list[dict]): R√©sultats accumul√©s apr√®s `parse()`.
        sanitizer (HTMLSanitizer): Sanitizeur HTML pour la description longue.
    """

    def __init__(self, gpx_file: Path):
        """Initialiser le parseur GPX.

        Description:
            Conserve le chemin vers le GPX, initialise les espaces de noms attendus
            et pr√©pare les structures internes (liste `caches`, sanitizeur HTML).

        Args:
            gpx_file (Path): Chemin du fichier GPX √† analyser.

        Returns:
            None
        """
        self.gpx_file = gpx_file
        self.namespaces = {
            "gpx": "http://www.topografix.com/GPX/1/0",
            "groundspeak": "http://www.groundspeak.com/cache/1/0/1",
            "gsak": "http://www.gsak.net/xmlv1/6",
        }
        self.caches: list[dict] = []
        self.sanitizer = HTMLSanitizer()

    def test(self):
        """Lister tous les tags XML (debug).

        Description:
            Parse le fichier et it√®re sur tous les √©l√©ments pour imprimer
            leurs `tag` (utilitaire de mise au point).

        Args:
            None

        Returns:
            None
        """
        tree = etree.parse(str(self.gpx_file))
        for elem in tree.getroot().iter():
            print(elem.tag)

    def parse(self) -> list[dict]:
        """Analyser le GPX et remplir `self.caches`.

        Description:
            - Parcourt les waypoints `//gpx:wpt` et cherche le sous-√©l√©ment `groundspeak:cache`.\n
            - Pour chaque cache finale (`_is_final_waypoint`), extrait les champs utiles
                (GC, titre, coords, type, taille, owner, D/T, pays/√©tat, description HTML
                nettoy√©e, favoris GSAK, notes, dates, attributs via `_parse_attributes`).\n
            - Empile chaque dict dans `self.caches`.

        Args:
            None

        Returns:
            list[dict]: Liste de caches structur√©es pr√™tes √† l‚Äôimport.
        """
        tree = etree.parse(str(self.gpx_file))
        nodes: Any = tree.xpath("//gpx:wpt", namespaces=self.namespaces)
        if not isinstance(nodes, list):
            raise ValueError("XPath did not return nodes")

        for wpt in nodes:
            cache_elem = wpt.find("groundspeak:cache", namespaces=self.namespaces)
            if cache_elem is None:
                continue

            is_final = self._is_final_waypoint(cache_elem)
            if is_final:
                cache = {
                    "GC": self.find_text_deep(wpt, "gpx:name"),
                    "title": self.find_text_deep(wpt, "gpx:desc"),
                    "latitude": float(wpt.attrib["lat"]),
                    "longitude": float(wpt.attrib["lon"]),
                    "cache_type": self.find_text_deep(wpt, "groundspeak:type"),
                    "cache_size": self.find_text_deep(wpt, "groundspeak:container"),
                    "owner": self.find_text_deep(wpt, "groundspeak:owner"),
                    "difficulty": self.find_text_deep(wpt, "groundspeak:difficulty"),
                    "terrain": self.find_text_deep(wpt, "groundspeak:terrain"),
                    "country": self.find_text_deep(wpt, "groundspeak:country"),
                    "state": self.find_text_deep(wpt, "groundspeak:state"),
                    "description_html": self.sanitizer.clean_description_html(
                        self.find_text_deep(wpt, "groundspeak:long_description")
                    ),
                    "favorites": int(self.find_text_deep(wpt, "gsak:FavPoints") or 0),
                    "notes": self.find_text_deep(wpt, "gsak:GcNote"),
                    "placed_date": self.find_text_deep(wpt, "gpx:time"),
                    "found_date": self.find_text_deep(wpt, "gsak:UserFound"),
                    "attributes": self._parse_attributes(cache_elem),
                }
                self.caches.append(cache)

        return self.caches

    def _parse_attributes(self, cache_elem) -> list[dict]:
        """Extraire la liste des attributs depuis `<groundspeak:attributes>`.

        Description:
            Parcourt les n≈ìuds `groundspeak:attribute` et retourne des objets
            `{id: int, is_positive: bool, name: str}`.

        Args:
            cache_elem: √âl√©ment XML `<groundspeak:cache>` parent.

        Returns:
            list[dict]: Attributs normalis√©s (id / inc / libell√©).
        """
        attrs = []
        for attr in cache_elem.xpath(
            "groundspeak:attributes/groundspeak:attribute", namespaces=self.namespaces
        ):
            attrs.append(
                {
                    "id": int(attr.get("id")),
                    "is_positive": attr.get("inc") == "1",
                    "name": attr.text.strip() if attr.text else "",
                }
            )

        return attrs

    def _has_corrected_coordinates(self, wpt_elem) -> bool:
        """Indiquer si la cache a des coordonn√©es corrig√©es (placeholder).

        Description:
            D√©tecteur de coordonn√©es corrig√©es (ex. myst√®re r√©solue). Impl√©mentation
            laiss√©e volontairement minimale ; le retour peut √™tre affin√© selon besoin.

        Args:
            wpt_elem: √âl√©ment XML `<gpx:wpt>`.

        Returns:
            bool: True si coordonn√©es corrig√©es d√©tect√©es, sinon False.
        """
        gsak_infos = wpt_elem.find("gsak:wptExtension", None)
        if gsak_infos is not None:
            print(gsak_infos)
        return wpt_elem.find("gsak:corrected", namespaces=self.namespaces) is not None

    def _has_found_log(self, cache_elem) -> bool:
        """V√©rifier la pr√©sence d‚Äôun log ¬´ Found it ¬ª.

        Description:
            Cherche un n≈ìud `groundspeak:log` dont le `type` (texte) vaut ¬´ Found it ¬ª.

        Args:
            cache_elem: √âl√©ment XML `<groundspeak:cache>`.

        Returns:
            bool: True si au moins un log ¬´ Found it ¬ª est pr√©sent, sinon False.
        """
        for log in cache_elem.xpath("groundspeak:logs/groundspeak:log", namespaces=self.namespaces):
            log_type = self._text(log.find("groundspeak:type", namespaces=self.namespaces))
            if log_type.lower() == "found it":
                return True
        return False

    def _was_found(self, wpt_elem) -> bool:
        """D√©terminer si la cache a un indicateur GSAK ¬´ UserFound ¬ª.

        Description:
            V√©rifie la pr√©sence d‚Äôun champ `gsak:UserFound`/`gsak:userfound` indiquant
            que la cache a √©t√© logu√©e trouv√©e par l‚Äôutilisateur c√¥t√© GSAK.

        Args:
            wpt_elem: √âl√©ment XML `<gpx:wpt>`.

        Returns:
            bool: True si indicateur pr√©sent, sinon False.
        """
        return wpt_elem.find("gsak:userfound", namespaces=self.namespaces) is not None

    def _is_final_waypoint(self, cache_elem) -> bool:
        """Filtrer les waypoints finaux (placeholder).

        Description:
            Point d‚Äôextension pour n‚Äôextraire que certains waypoints (ex. finals).
            Impl√©mentation actuelle retourne syst√©matiquement True.

        Args:
            cache_elem: √âl√©ment XML `<groundspeak:cache>`.

        Returns:
            bool: True si le waypoint doit √™tre conserv√©.
        """
        return True

    def _text(self, element, default: str = "") -> str:
        """Lire le texte d‚Äôun √©l√©ment (strip), avec d√©faut.

        Args:
            element: √âl√©ment XML ou None.
            default (str): Valeur par d√©faut si texte absent.

        Returns:
            str: Contenu textuel nettoy√©.
        """
        return element.text.strip() if element is not None and element.text else default

    def _html(self, element, default: str = "") -> str:
        """Lire du HTML (texte) et le d√©s√©chapper.

        Description:
            Retourne `html.unescape(element.text.strip())` si pr√©sent.

        Args:
            element: √âl√©ment XML ou None.
            default (str): Valeur par d√©faut si vide.

        Returns:
            str: HTML d√©s√©chapp√© (ou cha√Æne vide).
        """
        return html.unescape(element.text.strip()) if element is not None and element.text else ""

    def get_caches(self) -> list[dict]:
        """R√©cup√©rer la liste des caches d√©j√† extraites.

        Args:
            None

        Returns:
            list[dict]: Valeur actuelle de `self.caches`.
        """
        return self.caches

    def find_text_deep(self, element, tag: str) -> str:
        """Trouver du texte via XPath relatif (`.//{tag}`).

        Description:
            Ex√©cute `element.xpath(f".//{tag}", namespaces=self.namespaces)` et retourne
            le premier texte trouv√© (strip) ou une cha√Æne vide.

        Args:
            element: √âl√©ment de d√©part pour la recherche.
            tag (str): Tag XPath qualifi√© par pr√©fixe (ex. `gpx:name`).

        Returns:
            str: Texte trouv√©, sinon cha√Æne vide.
        """
        found = element.xpath(f".//{tag}", namespaces=self.namespaces)
        return found[0].text.strip() if found and len(found) and found[0].text else ""

                            </pre>
                        </code>
                    </div>
                </dialog>
                <aside class="notes">
                    <a href="assets/13/gpx-parser.png">Parser GPX</a>
                </aside>
            </section>

            <section>
                <h2>Composant m√©tier ‚Äî Moteur AST</h2>
                <ul>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_14_ast_grammar">Grammaire AST (conditions / agr√©gats)</a></li>
                    <li class="fragment diapo__item"><a class="dialog_toggler" href="#dialog_14_query_builder">Compilation => requ√™tes MongoDB (QueryBuilder)</a></li>
                </ul>
                <dialog class="dialog" id="dialog_14_ast_grammar">
                    <h3 class="dialog__title">Grammaire AST</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
# backend/app/models/challenge_ast.py
# AST d√©crivant les s√©lecteurs/r√®gles de t√¢ches et la logique (and/or/not) c√¥t√© UserChallenge.

from __future__ import annotations

from datetime import date
from typing import Any, Literal, Union

from pydantic import BaseModel, ConfigDict, Field

from app.core.bson_utils import PyObjectId


class ASTBase(BaseModel):
    """Base Pydantic pour tous les n≈ìuds AST.

    Description:
        Active les encoders `PyObjectId` et `populate_by_name`, tol√®re les types arbitraires,
        afin d‚Äôobtenir un JSON/OpenAPI propre pour Swagger.
    """

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={PyObjectId: str},
        populate_by_name=True,
    )


# ---- Cache-level leaves ----
## --- Selectors ---
class TypeSelector(ASTBase):
    """S√©lecteur par type de cache.

    Attributes:
        cache_type_doc_id (PyObjectId | None): R√©f. `cache_types._id`.
        cache_type_id (int | None): Identifiant num√©rique global.
        cache_type_code (str | None): Code type (ex. "whereigo").
    """

    cache_type_doc_id: PyObjectId | None = None
    cache_type_id: int | None = None
    code: str | None = Field(
        default=None, description="Cache type code, e.g. 'whereigo'"
    )


class SizeSelector(ASTBase):
    """S√©lecteur par taille de cache.

    Attributes:
        cache_size_doc_id (PyObjectId | None): R√©f. `cache_sizes._id`.
        cache_size_id (int | None): Identifiant num√©rique global.
        code (str | None): Code de taille.
    """

    cache_size_doc_id: PyObjectId | None = None
    cache_size_id: int | None = None
    code: str | None = Field(default=None, description="Cache size code")


class StateSelector(ASTBase):
    """S√©lecteur par √âtat/r√©gion.

    Attributes:
        state_id (int | None): Identifiant num√©rique (r√©f√©rentiel).
        name (str | None): Nom de l‚Äô√âtat/r√©gion.
    """

    state_id: int | None = None
    name: str | None = Field(default=None, description="Cache state")


class CountrySelector(ASTBase):
    """S√©lecteur par pays.

    Attributes:
        country_id (int | None): Identifiant num√©rique (r√©f√©rentiel).
        name (str | None): Nom du pays.
    """

    country_id: int | None = None
    name: str | None = Field(default=None, description="Cache country")


class AttributeSelector(ASTBase):
    """S√©lecteur par attribut(s) de cache.

    Attributes:
        cache_attribute_doc_id (PyObjectId | None): R√©f. `cache_attributes._id`.
        cache_attribute_id (int | None): Identifiant num√©rique global.
        code (str | None): Code attribut (ex. "picnic").
        is_positive (bool): True si l‚Äôattribut est affirmatif.
    """

    cache_attribute_doc_id: PyObjectId | None = None
    cache_attribute_id: int | None = None
    code: str | None = Field(default=None, description="Cache attribute code, e.g. 'picnic'")
    is_positive: bool = True


## --- Rules ---
class RuleTypeIn(ASTBase):
    """R√®gle: type ‚àà {‚Ä¶}."""

    kind: Literal["type_in"] = "type_in"
    types: list[TypeSelector]


class RuleSizeIn(ASTBase):
    """R√®gle: taille ‚àà {‚Ä¶}."""

    kind: Literal["size_in"] = "size_in"
    sizes: list[SizeSelector]


class RulePlacedYear(ASTBase):
    """R√®gle: cache plac√©e l‚Äôann√©e donn√©e (born√©e c√¥t√© mod√®le)."""

    kind: Literal["placed_year"] = "placed_year"
    year: int = Field(ge=1999, le=2100)


class RulePlacedBefore(ASTBase):
    """R√®gle: cache plac√©e **avant** la date donn√©e (incluse/exclue selon logique d‚Äô√©valuation)."""

    kind: Literal["placed_before"] = "placed_before"
    date: date


class RulePlacedAfter(ASTBase):
    """R√®gle: cache plac√©e **apr√®s** la date donn√©e (incluse/exclue selon logique d‚Äô√©valuation)."""

    kind: Literal["placed_after"] = "placed_after"
    date: date


class RuleStateIn(ASTBase):
    """R√®gle: √âtat ‚àà {‚Ä¶} (liste d‚ÄôObjectId)."""

    kind: Literal["state_in"] = "state_in"
    state_ids: list[PyObjectId]


class RuleCountryIs(ASTBase):
    """R√®gle: pays == valeur (s√©lecteur unique)."""

    kind: Literal["country_is"] = "country_is"
    country: CountrySelector


class RuleDifficultyBetween(ASTBase):
    """R√®gle: difficult√© ‚àà [min, max] (1.0‚Äì5.0)."""

    kind: Literal["difficulty_between"] = "difficulty_between"
    min: float = Field(ge=1.0, le=5.0)
    max: float = Field(ge=1.0, le=5.0)


class RuleTerrainBetween(ASTBase):
    """R√®gle: terrain ‚àà [min, max] (1.0‚Äì5.0)."""

    kind: Literal["terrain_between"] = "terrain_between"
    min: float = Field(ge=1.0, le=5.0)
    max: float = Field(ge=1.0, le=5.0)


class RuleAttributes(ASTBase):
    """R√®gle: ensemble d‚Äôattributs (¬±)."""

    kind: Literal["attributes"] = "attributes"
    attributes: list[AttributeSelector]


# ---- Aggregate leaves (apply to the set of eligible finds) ----
class RuleAggSumDifficultyAtLeast(ASTBase):
    """R√®gle agr√©g√©e: somme(difficult√©) ‚â• min_total (sur l‚Äôensemble de trouvailles √©ligibles)."""

    kind: Literal["aggregate_sum_difficulty_at_least"] = "aggregate_sum_difficulty_at_least"
    min_total: int = Field(ge=1)


class RuleAggSumTerrainAtLeast(ASTBase):
    """R√®gle agr√©g√©e: somme(terrain) ‚â• min_total (sur l‚Äôensemble de trouvailles √©ligibles)."""

    kind: Literal["aggregate_sum_terrain_at_least"] = "aggregate_sum_terrain_at_least"
    min_total: int = Field(ge=1)


class RuleAggSumDiffPlusTerrAtLeast(ASTBase):
    """R√®gle agr√©g√©e: somme(difficult√©+terrain) ‚â• min_total."""

    kind: Literal["aggregate_sum_diff_plus_terr_at_least"] = "aggregate_sum_diff_plus_terr_at_least"
    min_total: int = Field(ge=1)


class RuleAggSumAltitudeAtLeast(ASTBase):
    """R√®gle agr√©g√©e: somme(altitude) ‚â• min_total."""

    kind: Literal["aggregate_sum_altitude_at_least"] = "aggregate_sum_altitude_at_least"
    min_total: int = Field(ge=1)


TaskLeaf = Union[
    RuleTypeIn,
    RuleSizeIn,
    RulePlacedYear,
    RulePlacedBefore,
    RulePlacedAfter,
    RuleStateIn,
    RuleCountryIs,
    RuleDifficultyBetween,
    RuleTerrainBetween,
    RuleAttributes,
    RuleAggSumDifficultyAtLeast,
    RuleAggSumTerrainAtLeast,
    RuleAggSumDiffPlusTerrAtLeast,
    RuleAggSumAltitudeAtLeast,
]


class TaskAnd(ASTBase):
    """N≈ìud logique AND.

    Attributes:
        nodes (list[TaskAnd | TaskOr | TaskNot | TaskLeaf]): Sous-n≈ìuds.
    """

    kind: Literal["and"] = "and"
    nodes: list[TaskAnd | TaskOr | TaskNot | TaskLeaf]


class TaskOr(ASTBase):
    """N≈ìud logique OR.

    Attributes:
        nodes (list[TaskAnd | TaskOr | TaskNot | TaskLeaf]): Sous-n≈ìuds.
    """

    kind: Literal["or"] = "or"
    nodes: list[TaskAnd | TaskOr | TaskNot | TaskLeaf]


class TaskNot(ASTBase):
    """N≈ìud logique NOT.

    Attributes:
        node (TaskAnd | TaskOr | TaskLeaf): Sous-n≈ìud.
    """

    kind: Literal["not"] = "not"
    node: TaskAnd | TaskOr | TaskLeaf


TaskExpression = TaskAnd | TaskOr | TaskNot | TaskLeaf
TaskAnd.model_rebuild()
TaskOr.model_rebuild()
TaskNot.model_rebuild()


# ---- UC-level logic (composition by task ids, unchanged) ----
class UCAnd(ASTBase):
    """Logique UC: AND des `task_ids`."""

    kind: Literal["and"] = "and"
    task_ids: list[PyObjectId]


class UCOr(ASTBase):
    """Logique UC: OR des `task_ids`."""

    kind: Literal["or"] = "or"
    task_ids: list[PyObjectId]


class UCNot(ASTBase):
    """Logique UC: NOT d‚Äôun `task_id`."""

    kind: Literal["not"] = "not"
    task_id: PyObjectId


UCLogic = Union[UCAnd, UCOr, UCNot]

# Les kinds logiques et les kinds "feuilles" (r√®gles) connus
_LOGICAL_KINDS = {"and", "or", "not"}
_RULE_KINDS = {
    "attributes",
    "type_in",
    "size_in",
    "placed_year",
    "placed_before",
    "placed_after",
    "state_in",
    "country_is",
    "difficulty_between",
    "terrain_between",
    "aggregate_sum_difficulty_at_least",
    "aggregate_sum_terrain_at_least",
    "aggregate_sum_diff_plus_terr_at_least",
    "aggregate_sum_altitude_at_least",
}


def preprocess_expression_default_and(expr: Any) -> Any:
    """Normalise une expression courte en `AND` explicite.

    Description:
        Transforme les √©critures abr√©g√©es (sans `kind`, avec r√®gles directes, etc.)
        en une structure canonique o√π `kind='and'` et les r√®gles sont dans `nodes`.
        Appel√©e **avant** la validation Pydantic de l‚ÄôAST.

    Args:
        expr (Any): Expression brute (dict/objets/‚Ä¶).

    Returns:
        Any: Expression normalis√©e (dict) pr√™te pour la validation.
    """
    # Cas non-dict (list, str, etc.) ‚Üí inchang√©
    if not isinstance(expr, dict):
        return expr

    # Si pas de 'kind' ‚Üí c'est un AND implicite
    if "kind" not in expr:
        # Si d√©j√† une liste de 'nodes', on force 'and'
        if "nodes" in expr and isinstance(expr["nodes"], list):
            return {"kind": "and", "nodes": expr["nodes"]}

        # D√©tection d'une "r√®gle courte" (attributs/typage directs)
        looks_like_rule = any(
            k in expr
            for k in (
                "attributes",
                "type_ids",
                "codes",
                "size_ids",
                "year",
                "date",
                "state_ids",
                "country_id",
                "min",
                "max",
                "min_total",
            )
        )
        if looks_like_rule:
            return {"kind": "and", "nodes": [expr]}

        # Sinon, on met quand m√™me un AND vide (laisser la validation g√©rer)
        return {"kind": "and", "nodes": expr.get("nodes", [])}

    # Si 'kind' est une r√®gle au sommet ‚Üí envelopper dans un AND
    k = expr.get("kind")
    if isinstance(k, str) and k in _RULE_KINDS:
        return {"kind": "and", "nodes": [expr]}

    # Si 'kind' est logique mais sans nodes et qu'on voit des champs de r√®gle,
    # on transforme en nodes=[ ce dict moins 'kind' ] (rare, mais utile)
    if isinstance(k, str) and k in _LOGICAL_KINDS and not expr.get("nodes"):
        looks_like_rule = any(
            field in expr
            for field in (
                "attributes",
                "type_ids",
                "codes",
                "size_ids",
                "year",
                "date",
                "state_ids",
                "country_id",
                "min",
                "max",
                "min_total",
            )
        )
        if looks_like_rule:
            rule_like = {kk: vv for kk, vv in expr.items() if kk != "kind"}
            return {"kind": k, "nodes": [rule_like]}

    # D√©j√† canonique
    return expr
                                
                            </pre>
                        </code>
                    </div>
                </dialog>
                <dialog class="dialog" id="dialog_14_query_builder">
                    <h3 class="dialog__title">Qury builder</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
# backend/app/services/query_builder.py
# Transforme une expression canonique (AND-only) en conditions MongoDB pour la collection `caches`.

from __future__ import annotations

from datetime import date, datetime
from typing import Any

from bson import ObjectId

from app.services.referentials_cache import (
    resolve_attribute_code,
    resolve_country_name,
    resolve_size_code,
    resolve_size_name,
    resolve_state_name,
    resolve_type_code,
)

# NOTE: on ne d√©pend pas des mod√®les Pydantic ici : on re√ßoit un dict "expression" d√©j√† canonis√©
# (cf. services/user_challenge_tasks.put_tasks qui stocke l'expression canonicalis√©e). :contentReference[oaicite:1]{index=1}


def _mk_date(dt_or_str: Any) -> datetime:
    """Normaliser divers formats de date vers `datetime`.

    Description:
        Accepte `datetime`, `date` ou `str` (ISO ou `YYYY-MM-DD`). L√®ve `ValueError` pour les formats invalides.

    Args:
        dt_or_str (Any): Valeur de date/heure √† convertir.

    Returns:
        datetime: Date normalis√©e.
    """
    if isinstance(dt_or_str, datetime):
        return dt_or_str
    if isinstance(dt_or_str, date):
        return datetime(dt_or_str.year, dt_or_str.month, dt_or_str.day)
    if isinstance(dt_or_str, str):
        if len(dt_or_str) == 10:
            y, m, d = [int(x) for x in dt_or_str.split("-")]
            return datetime(y, m, d)
        return datetime.fromisoformat(dt_or_str)
    raise ValueError(f"Invalid date: {dt_or_str!r}")


def _flatten_and_nodes(expr: dict[str, Any]) -> list[dict[str, Any]] | None:
    """Aplatir r√©cursivement les n≈ìuds `AND` en une liste de feuilles.

    Description:
        Retourne `None` si l‚Äôexpression contient des `OR`/`NOT` (non support√©s par le compilateur ¬´ AND-only ¬ª).

    Args:
        expr (dict): Expression AST canonique.

    Returns:
        list[dict] | None: Feuilles si AND pur, sinon None.
    """
    kind = expr.get("kind")
    if kind == "and":
        out: list[dict[str, Any]] = []
        for n in expr.get("nodes") or []:
            sub = _flatten_and_nodes(n) if isinstance(n, dict) else [n]
            if sub is None:
                return None
            out.extend(sub)
        return out
    if kind in ("or", "not"):
        return None
    return [expr]  # leaf


def _extract_aggregate_spec(
    leaves: list[dict[str, Any]]
) -> tuple[dict[str, Any] | None, list[dict[str, Any]]]:
    """Extraire la sp√©cification d‚Äôagr√©gat et les feuilles ¬´ cache.* ¬ª.

    Description:
        D√©tecte la **premi√®re** feuille d‚Äôagr√©gat parmi:
        - `aggregate_sum_difficulty_at_least`
        - `aggregate_sum_terrain_at_least`
        - `aggregate_sum_diff_plus_terr_at_least`
        - `aggregate_sum_altitude_at_least`
        Retourne `(agg_spec, leaves_sans_agr√©gat)`.

    Args:
        leaves (list[dict]): Feuilles AND.

    Returns:
        tuple[dict | None, list[dict]]: Sp√©c d‚Äôagr√©gat (ou None) et feuilles restantes.
    """
    agg = None
    cache_leaves: list[dict[str, Any]] = []
    for lf in leaves:
        k = lf.get("kind")
        if k in (
            "aggregate_sum_difficulty_at_least",
            "aggregate_sum_terrain_at_least",
            "aggregate_sum_diff_plus_terr_at_least",
            "aggregate_sum_altitude_at_least",
        ):
            if agg is None and lf.get("min_total") is not None:
                mt = int(lf["min_total"])
                if k == "aggregate_sum_difficulty_at_least":
                    agg = {"kind": "difficulty", "min_total": mt}
                elif k == "aggregate_sum_terrain_at_least":
                    agg = {"kind": "terrain", "min_total": mt}
                elif k == "aggregate_sum_diff_plus_terr_at_least":
                    agg = {"kind": "diff_plus_terr", "min_total": mt}
                elif k == "aggregate_sum_altitude_at_least":
                    agg = {"kind": "altitude", "min_total": mt}
        else:
            cache_leaves.append(lf)
    return agg, cache_leaves


def _compile_leaf_to_cache_pairs(leaf: dict[str, Any]) -> list[tuple[str, Any]]:
    """Compiler une feuille AST en `(champ, condition)` sur `caches`.

    Description:
        Supporte notamment:
        - `type_in`, `size_in` (r√©solution via r√©f√©rentiels/aliases)
        - `country_is`, `state_in`
        - `placed_year`, `placed_before`, `placed_after`
        - `difficulty_between`, `terrain_between`
        - `attributes` (¬±, `attributes.$elemMatch`)

    Args:
        leaf (dict): Feuille individuelle.

    Returns:
        list[tuple[str, Any]]: Paires `(champ, condition)` √† fusionner en AND.
    """
    k = leaf.get("kind")
    out: list[tuple[str, Any]] = []

    oids: list[ObjectId] = []
    if k == "type_in":
        # 1) canonique: types: [{cache_type_doc_id | cache_type_id | cache_type_code}]
        for t in leaf.get("types") or []:
            oid = t.get("cache_type_doc_id")
            if not oid and t.get("cache_type_id") is not None:
                # numeric id non support√© nativement par le cache -> on ignore, ou ajoute si tu l‚Äôas dans cache
                pass
            if not oid and t.get("cache_type_code"):
                oid = resolve_type_code(t["cache_type_code"])
            if oid:
                oids.append(oid)

        # 2) legacy: codes: ["wherigo", ...]
        for code in leaf.get("codes") or []:
            oid = resolve_type_code(code)
            if oid:
                oids.append(oid)

        # 3) legacy: type_ids: [<oid>, ...]
        for tid in leaf.get("type_ids") or []:
            try:
                oids.append(ObjectId(str(tid)))
            except Exception:
                pass

        if oids:
            out.append(("type_id", {"$in": list(dict.fromkeys(oids))}))
        return out

    if k == "size_in":
        # 1) canonique: sizes: [{cache_size_doc_id | cache_size_id | code | name}]
        for s in leaf.get("sizes") or []:
            oid = s.get("cache_size_doc_id")
            if not oid and s.get("code"):
                oid = resolve_size_code(s["code"])
            if not oid and s.get("name"):
                oid = resolve_size_name(s["name"])
            if oid:
                oids.append(ObjectId(str(oid)))

        # 2) legacy: codes: ["micro", ...]
        for code in leaf.get("codes") or []:
            oid = resolve_size_code(code)
            if oid:
                oids.append(ObjectId(str(oid)))

        # 3) legacy: names: ["micro", ...]
        for nm in leaf.get("names") or []:
            oid = resolve_size_name(nm)
            if oid:
                oids.append(ObjectId(str(oid)))

        # 3) legacy: size_ids: [<oid>, ...]
        for sid in leaf.get("size_ids") or []:
            try:
                oids.append(ObjectId(str(sid)))
            except Exception:
                pass

        if oids:
            out.append(("size_id", {"$in": list(dict.fromkeys(oids))}))
        return out

    if k == "country_is":
        # Accepter leaf.country_id OU leaf.country.{code|name}
        cid = leaf.get("country_id")
        if not cid:
            c = leaf.get("country") or {}
            if c.get("code"):
                # Le cache pays est index√© par 'name'; ici on ne l‚Äôa que par name => on tente d‚Äôabord name,
                # sinon on peut √©tendre referentials_cache pour g√©rer code si tu en as.
                # Si tes pays n‚Äôont pas "code", utilise resolve_country_name uniquement.
                cid = resolve_country_name(c.get("name") or c.get("code", ""))
            elif c.get("name"):
                cid = resolve_country_name(c["name"])
        if cid:
            out.append(("country_id", cid))
        else:
            # clause impossible -> 0 match (√©viter faux positifs)
            out.append(("_id", ObjectId()))  # _id impossible
        return out

    if k == "state_in":
        # Accepte state_ids OU states[{name}] (avec country diffusable via sibling)
        ids: list[ObjectId] = list(leaf.get("state_ids") or [])

        for s in leaf.get("states") or []:
            sid = s.get("state_id")
            if not sid and s.get("name"):
                # on passe le country_id du leaf s‚Äôil est d√©j√† l√†
                country_id = leaf.get("country_id") or (leaf.get("country") or {}).get("country_id")
                sid, _err = resolve_state_name(s["name"], country_id=country_id)
            if sid:
                try:
                    ids.append(ObjectId(str(sid)))
                except Exception:
                    pass

        if ids:
            out.append(("state_id", {"$in": list(dict.fromkeys(ids))}))
        else:
            out.append(("_id", ObjectId()))  # clause impossible
        return out

    if k == "placed_year":
        y = int(leaf.get("year", 0))
        start = datetime(y, 1, 1)
        end = datetime(y + 1, 1, 1)
        out.append(("placed_at", {"$gte": start, "$lt": end}))
        return out

    if k == "placed_before":
        out.append(("placed_at", {"$lt": _mk_date(leaf.get("date"))}))
        return out

    if k == "placed_after":
        out.append(("placed_at", {"$gt": _mk_date(leaf.get("date"))}))
        return out

    if k == "difficulty_between":
        out.append(("difficulty", {"$gte": float(leaf["min"]), "$lte": float(leaf["max"])}))
        return out

    if k == "terrain_between":
        out.append(("terrain", {"$gte": float(leaf["min"]), "$lte": float(leaf["max"])}))
        return out

    if k == "attributes":
        # Canonique: [{"cache_attribute_doc_id"| "cache_attribute_id" | "code", "is_positive": bool}]
        attrs = leaf.get("attributes") or []
        for a in attrs:
            is_pos = bool(a.get("is_positive", True))
            attr_oid = a.get("cache_attribute_doc_id") or a.get("attribute_doc_id")
            if not attr_oid and a.get("cache_attribute_id") is not None:
                # le cache retourne aussi l'id num√©rique via resolve_attribute_code(code) si tu veux;
                # ici on reste doc_id only
                pass
            if not attr_oid and a.get("code"):
                res = resolve_attribute_code(a["code"])
                attr_oid = res[0] if res else None

            if attr_oid:
                out.append(
                    (
                        "attributes",
                        {
                            "$elemMatch": {
                                "attribute_doc_id": ObjectId(str(attr_oid)),
                                "is_positive": is_pos,
                            }
                        },
                    )
                )
            else:
                out.append(("_id", ObjectId()))  # clause impossible

        # legacy: "codes": ["picnic", "challenge"] (positifs)
        for code in leaf.get("codes") or []:
            res = resolve_attribute_code(code)
            if res and res[0]:
                out.append(
                    (
                        "attributes",
                        {
                            "$elemMatch": {
                                "attribute_doc_id": ObjectId(str(res[0])),
                                "is_positive": True,
                            }
                        },
                    )
                )
            else:
                out.append(("_id", ObjectId()))

        return out

    return out


def compile_and_only(
    expr: dict[str, Any]
) -> tuple[str, dict[str, Any], bool, list[str], dict[str, Any] | None]:
    """Compiler une expression AND en filtres Mongo ¬´ caches.* ¬ª.

    Description:
        - Rejette `OR`/`NOT` (`supported=False`, notes).\n
        - Extrait un √©ventuel agr√©gat (diff/terr/diff+terr/altitude).\n
        - Compile chaque feuille en paires `(champ, condition)` et fusionne par champ (AND).\n
        - G√©n√®re une signature stable de l‚Äôexpression (`"and:" + json.dumps(leaves)`).

    Args:
        expr (dict): Expression canonique.

    Returns:
        tuple:
            str: Signature compil√©e.
            dict: `match_caches` ‚Äî conditions AND par champ.
            bool: `supported` ‚Äî True si AND pur.
            list[str]: `notes` ‚Äî avertissements/causes de non-support.
            dict | None: `aggregate_spec` ‚Äî sp√©cification d‚Äôagr√©gat.
    """
    leaves = _flatten_and_nodes(expr)
    if leaves is None:
        return ("unsupported:or-not", {}, False, ["or/not unsupported in MVP"], None)

    agg_spec, cache_leaves = _extract_aggregate_spec(leaves)
    parts: list[tuple[str, Any]] = []
    for lf in cache_leaves:
        parts.extend(_compile_leaf_to_cache_pairs(lf))

    # fusion (AND): grouper par champ; si plusieurs conds pour un m√™me champ -> liste ET-√©e
    match: dict[str, Any] = {}
    for field, cond in parts:
        if field in match:
            if not isinstance(match[field], list):
                match[field] = [match[field]]
            match[field].append(cond)
        else:
            match[field] = cond

    try:
        import json

        signature = "and:" + json.dumps({"leaves": cache_leaves}, default=str, sort_keys=True)
    except Exception:
        signature = "and:compiled"

    return (signature, match, True, [], agg_spec)
                                
                            </pre>
                        </code>
                    </div>
                </dialog>
                <aside class="notes">
                    Grammaire AST : flexible et √©volutif<br>
                    Compilation AST requ√™te : adaptable √† l'√©volution
                </aside>
            </section>

            <section>
                <h2>Acc√®s donn√©es ‚Äî Recherche g√©ospatiale</h2>
                <ul>
                    <li class="fragment diapo__item">$geoNear + <a class="dialog_toggler" href="#dialog_15_2dsphere">index 2dsphere</a></li>
                    <li class="fragment diapo__item">Pipelines d‚Äôagr√©gation, pagination, projection compacte</li>
                </ul>
                <aside class="notes">
                    Index 2d sphere : grande stabilit√©, performance logarithmique - lin√©aire => performant m√™me avec gros volumes<br>
                    <p>
                        Dans les tests sur un n≈ìud unique avec 1 million de documents et distribution uniforme, MongoDB a montr√© des d√©bits sup√©rieurs pour les requ√™tes g√©ospatiales par rapport √† Couchbase. La diff√©rence de d√©bit entre les requ√™tes "near" et "box" dans MongoDB √©tait de 19,5%, tandis que dans Couchbase cette diff√©rence √©tait de 64,4%.
                    </p>
                    <p>
                        Source : Benchmarking Scalability of NoSQL Databases for Geospatial Queries (San Jose State University, Theses and Graduate Research) (https://scholarworks.sjsu.edu/cgi/viewcontent.cgi?article=1674&context=etd_projects)
                    </p>

                    Comment : structure B-Tree optimis√©e pour g√©ospatial
                </aside>
            </section>

            <section>
                <h2>Acc√®s donn√©es ‚Äî Calcul progression</h2>
                <ul>
                    <li class="fragment diapo__item">evaluate_progress() : <span class="diapo__item__content">snapshots
                            + s√©ries temporelles</span></li>
                    <li class="fragment diapo__item">MAJ statuts tasks/challenges</li>
                </ul>
                <dialog class="dialog" id="dialog_16_progress">
                    <h3 class="dialog__title">Calcul de progression</h3>
                    <div class="dialog__content">
                        <code>
                            <pre>
# backend/app/services/progress.py
# Calcule des snapshots de progression par UserChallenge, mise √† jour des statuts, et acc√®s √† l‚Äôhistorique.

from __future__ import annotations

import math
from datetime import date, datetime, timedelta
from typing import Any

from bson import ObjectId
from pymongo import ASCENDING, DESCENDING

from app.core.utils import now, utcnow
from app.db.mongodb import get_collection
from app.services.query_builder import compile_and_only

# ---------- Helpers ----------


def _ensure_uc_owned(user_id: ObjectId, uc_id: ObjectId) -> dict[str, Any]:
    """V√©rifier que l‚ÄôUC appartient bien √† l‚Äôutilisateur.

    Description:
        Contr√¥le l‚Äôexistence de `user_challenges[_id=uc_id, user_id=user_id]`. L√®ve en cas de non-appartenance.

    Args:
        user_id (ObjectId): Identifiant utilisateur.
        uc_id (ObjectId): Identifiant UserChallenge.

    Returns:
        dict: Document minimal (_id) si autoris√©.

    Raises:
        PermissionError: Si l‚ÄôUC n‚Äôappartient pas √† l‚Äôutilisateur (ou n‚Äôexiste pas).
    """
    ucs = get_collection("user_challenges")
    row = ucs.find_one({"_id": uc_id, "user_id": user_id}, {"_id": 1})
    if not row:
        raise PermissionError("UserChallenge not found or not owned by user")
    return row


def _get_tasks_for_uc(uc_id: ObjectId) -> list[dict[str, Any]]:
    """R√©cup√©rer les t√¢ches d‚Äôun UC (tri√©es).

    Args:
        uc_id (ObjectId): Identifiant UserChallenge.

    Returns:
        list[dict]: T√¢ches tri√©es par `order`, puis `_id`.
    """
    coll = get_collection("user_challenge_tasks")
    return list(coll.find({"user_challenge_id": uc_id}).sort([("order", 1), ("_id", 1)]))


def _attr_id_by_cache_attr_id(cache_attribute_id: int) -> ObjectId | None:
    """R√©soudre l‚ÄôObjectId d‚Äôun attribut de cache par ID num√©rique global.

    Args:
        cache_attribute_id (int): Identifiant num√©rique global (ex. 71).

    Returns:
        ObjectId | None: R√©f√©rence du document `cache_attributes` ou None.
    """
    row = get_collection("cache_attributes").find_one(
        {"cache_attribute_id": cache_attribute_id}, {"_id": 1}
    )
    return row["_id"] if row else None


def _count_found_caches_matching(user_id: ObjectId, match_caches: dict[str, Any]) -> int:
    """Compter les trouvailles d‚Äôun utilisateur qui matchent des conditions ¬´ caches.* ¬ª.

    Description:
        Pipeline: filtre par `user_id` sur `found_caches`, `$lookup` vers `caches`, `$unwind`,
        puis application des conditions (`match_caches`) sur `cache.*`, et `$count`.

    Args:
        user_id (ObjectId): Utilisateur concern√©.
        match_caches (dict): Conditions AND sur des champs de `caches`.

    Returns:
        int: Nombre de trouvailles correspondantes.
    """
    fc = get_collection("found_caches")
    pipeline: list[dict[str, Any]] = [
        {"$match": {"user_id": user_id}},
        {
            "$lookup": {
                "from": "caches",
                "localField": "cache_id",
                "foreignField": "_id",
                "as": "cache",
            }
        },
        {"$unwind": "$cache"},
    ]

    # Apply match on cache.*
    conds: list[dict[str, Any]] = []
    for field, cond in match_caches.items():
        if isinstance(cond, list):
            # multiple conditions for the same field => all must hold
            for c in cond:
                conds.append({f"cache.{field}": c})
        else:
            conds.append({f"cache.{field}": cond})
    if conds:
        pipeline.append({"$match": {"$and": conds}})
    pipeline.append({"$count": "current_count"})
    rows = list(fc.aggregate(pipeline, allowDiskUse=False))
    return int(rows[0]["current_count"]) if rows else 0


def _aggregate_total(user_id: ObjectId, match_caches: dict[str, Any], spec: dict[str, Any]) -> int:
    """Calculer une somme agr√©g√©e (difficult√©, terrain, diff+terr, altitude).

    Description:
        Filtre via `match_caches` puis somme la m√©trique demand√©e :
        - `difficulty` ‚Üí somme des difficult√©s
        - `terrain` ‚Üí somme des terrains
        - `diff_plus_terr` ‚Üí somme (difficult√© + terrain)
        - `altitude` ‚Üí somme des altitudes

    Args:
        user_id (ObjectId): Utilisateur.
        match_caches (dict): Conditions AND sur `caches`.
        spec (dict): Sp√©cification d‚Äôagr√©gat (`{'kind': ..., 'min_total': int}`).

    Returns:
        int: Total agr√©g√© (0 si `kind` inconnu).
    """
    fc = get_collection("found_caches")
    pipeline: list[dict[str, Any]] = [
        {"$match": {"user_id": user_id}},
        {
            "$lookup": {
                "from": "caches",
                "localField": "cache_id",
                "foreignField": "_id",
                "as": "cache",
            }
        },
        {"$unwind": "$cache"},
    ]
    # Apply match on cache.*
    conds: list[dict[str, Any]] = []
    for field, cond in match_caches.items():
        if isinstance(cond, list):
            for c in cond:
                conds.append({f"cache.{field}": c})
        else:
            conds.append({f"cache.{field}": cond})
    if conds:
        pipeline.append({"$match": {"$and": conds}})

    k = spec["kind"]
    if k == "difficulty":
        score_expr = {"$ifNull": ["$cache.difficulty", 0]}
    elif k == "terrain":
        score_expr = {"$ifNull": ["$cache.terrain", 0]}
    elif k == "diff_plus_terr":
        score_expr = {
            "$add": [
                {"$ifNull": ["$cache.difficulty", 0]},
                {"$ifNull": ["$cache.terrain", 0]},
            ]
        }
    elif k == "altitude":
        score_expr = {"$ifNull": ["$cache.elevation", 0]}
    else:
        return 0

    pipeline += [
        {"$project": {"score": score_expr}},
        {"$group": {"_id": None, "total": {"$sum": "$score"}}},
    ]
    rows = list(fc.aggregate(pipeline, allowDiskUse=False))
    return int(rows[0]["total"]) if rows else 0


def _nth_found_date(user_id: ObjectId, match_caches: dict[str, Any], n: int) -> date | None:
    if n <= 0:
        return None
    fc = get_collection("found_caches")
    pipeline = [
        {"$match": {"user_id": user_id}},
        {
            "$lookup": {
                "from": "caches",
                "localField": "cache_id",
                "foreignField": "_id",
                "as": "cache",
            }
        },
        {"$unwind": "$cache"},
    ]
    and_conds = []
    for field, cond in match_caches.items():
        if isinstance(cond, list):
            for c in cond:
                and_conds.append({f"cache.{field}": c})
        else:
            and_conds.append({f"cache.{field}": cond})
    if and_conds:
        pipeline.append({"$match": {"$and": and_conds}})
    pipeline += [
        {"$sort": {"found_date": ASCENDING}},
        {"$skip": max(0, n - 1)},
        {"$limit": 1},
        {"$project": {"_id": 0, "found_date": 1}},
    ]
    rows = list(fc.aggregate(pipeline, allowDiskUse=False))
    return rows[0]["found_date"] if rows else None


# alias pratique
def _first_found_date(user_id: ObjectId, match_caches: dict[str, Any]) -> date | None:
    return _nth_found_date(user_id, match_caches, 1)


# ---------- Public API ----------


def evaluate_progress(user_id: ObjectId, uc_id: ObjectId, force=False) -> dict[str, Any]:
    """√âvaluer les t√¢ches d‚Äôun UC et ins√©rer un snapshot.

    Description:
        - V√©rifie l‚Äôappartenance de l‚ÄôUC (`_ensure_uc_owned`).\n
        - Si `force=False` et que l‚ÄôUC est d√©j√† `completed`, retourne le dernier snapshot (si existant).\n
        - Pour chaque t√¢che, compile l‚Äôexpression (`compile_and_only`), compte les trouvailles, met √† jour
            √©ventuellement le statut de la t√¢che, calcule les agr√©gats et le pourcentage.\n
        - Calcule l‚Äôagr√©gat global et cr√©e un document `progress`. Si toutes les t√¢ches support√©es sont `done`,
            met √† jour `user_challenges` en `completed` (statuts d√©clar√© & calcul√©).

    Args:
        user_id (ObjectId): Utilisateur.
        uc_id (ObjectId): UserChallenge.
        force (bool): Forcer le recalcul m√™me si UC compl√©t√©.

    Returns:
        dict: Document snapshot ins√©r√© (avec `id` ajout√© pour la r√©ponse).
    """
    _ensure_uc_owned(user_id, uc_id)
    tasks = _get_tasks_for_uc(uc_id)
    snapshots: list[dict[str, Any]] = []
    sum_current = 0
    sum_min = 0
    tasks_supported = 0
    tasks_done = 0
    uc_statuses = get_collection("user_challenges").find_one(
        {"_id": uc_id}, {"status": 1, "computed_status": 1}
    )
    uc_status = (uc_statuses or {}).get("status")
    uc_computed_status = (uc_statuses or {}).get("computed_status")
    if (not force) and (uc_computed_status == "completed" or uc_status == "completed"):
        # Renvoyer le dernier snapshot existant, sans recalcul ni insertion
        last = get_collection("progress").find_one(
            {"user_challenge_id": uc_id}, sort=[("checked_at", -1), ("created_at", -1)]
        )
        if last:
            return last  # m√™me shape que vos snapshots persist√©s
        # S'il n'y a pas encore de snapshot, on retombe sur le calcul normal

    for t in tasks:
        min_count = int((t.get("constraints") or {}).get("min_count") or 0)
        title = t.get("title") or "Task"
        order = int(t.get("order") or 0)
        status = (t.get("status") or "todo").lower()
        expr = t.get("expression") or {}

        if status == "done" and not force:
            snap = {
                "task_id": t["_id"],
                "order": order,
                "title": title,
                "status": status,
                "supported_for_progress": True,
                "compiled_signature": "override:done",
                "min_count": min_count,
                "current_count": min_count,
                "percent": 100.0,
                "notes": ["user override: done"],
                "evaluated_in_ms": 0,
                "last_evaluated_at": now(),
                "updated_at": t.get("updated_at"),
                "created_at": t.get("created_at"),
            }
        else:
            sig, match_caches, supported, notes, agg_spec = compile_and_only(expr)
            if not supported:
                snap = {
                    "task_id": t["_id"],
                    "order": order,
                    "title": title,
                    "supported_for_progress": False,
                    "compiled_signature": sig,
                    "min_count": min_count,
                    "current_count": 0,
                    "percent": 0.0,
                    "notes": notes,
                    "evaluated_in_ms": 0,
                    "last_evaluated_at": now(),
                    "updated_at": t.get("updated_at"),
                    "created_at": t.get("created_at"),
                }
            else:
                tic = utcnow()
                current = _count_found_caches_matching(user_id, match_caches)
                ms = int((utcnow() - tic).total_seconds() * 1000)

                # base percent on min_count
                bounded = min(current, min_count) if min_count > 0 else current
                count_percent = (100.0 * (bounded / min_count)) if min_count > 0 else 100.0
                new_status = "done" if current >= min_count else status
                task_id = t["_id"]
                t["status"] = new_status
                if status != "done":
                    get_collection("user_challenge_tasks").update_one(
                        {"_id": task_id},
                        {
                            "$set": {
                                "status": new_status,
                                "last_evaluated_at": utcnow(),
                                "updated_at": utcnow(),
                            }
                        },
                    )

                # aggregate handling
                aggregate_total = None
                aggregate_target = None
                aggregate_percent = None
                aggregate_unit = None
                if agg_spec:
                    aggregate_total = _aggregate_total(user_id, match_caches, agg_spec)
                    aggregate_target = int(agg_spec.get("min_total", 0)) or None
                    if aggregate_target and aggregate_target > 0:
                        aggregate_percent = max(
                            0.0,
                            min(
                                100.0,
                                100.0 * (float(aggregate_total) / float(aggregate_target)),
                            ),
                        )
                    else:
                        aggregate_percent = None
                    # unit: altitude -> meters, otherwise points
                    aggregate_unit = "meters" if agg_spec.get("kind") == "altitude" else "points"

                # final percent rule (MVP):
                # - if both count & aggregate constraints exist -> percent = min(count_percent, aggregate_percent)
                # - if only count -> count_percent
                # - if only aggregate -> aggregate_percent or 0 if None
                if agg_spec and min_count > 0:
                    final_percent = min(count_percent, (aggregate_percent or 0.0))
                elif agg_spec and min_count == 0:
                    final_percent = aggregate_percent or 0.0
                else:
                    final_percent = count_percent

                # --- dates de progression persist√©es sur la task ---
                task_id = t["_id"]
                min_count = int((t.get("constraints") or {}).get("min_count") or 0)

                # 2.1 start_found_at : premi√®re trouvaille qui matche
                start_dt = _first_found_date(user_id, match_caches)
                if start_dt and not t.get("start_found_at"):
                    get_collection("user_challenge_tasks").update_one(
                        {"_id": task_id},
                        {"$set": {"start_found_at": start_dt, "updated_at": utcnow()}},
                    )
                    t["start_found_at"] = start_dt  # en m√©moire pour la suite

                # 2.2 completed_at : date de la min_count-i√®me trouvaille
                completed_dt = None
                if min_count > 0 and current >= min_count:
                    completed_dt = _nth_found_date(user_id, match_caches, min_count)

                # persister la date si atteinte, sinon l'annuler si elle existait mais plus valide
                if completed_dt:
                    if t.get("completed_at") != completed_dt:
                        get_collection("user_challenge_tasks").update_one(
                            {"_id": task_id},
                            {
                                "$set": {
                                    "completed_at": completed_dt,
                                    "updated_at": utcnow(),
                                }
                            },
                        )
                        t["completed_at"] = completed_dt
                else:
                    if t.get("completed_at") is not None:
                        get_collection("user_challenge_tasks").update_one(
                            {"_id": task_id},
                            {"$set": {"completed_at": None, "updated_at": utcnow()}},
                        )
                        t["completed_at"] = None

                snap = {
                    "task_id": t["_id"],
                    "order": order,
                    "title": title,
                    "status": t["status"],
                    "supported_for_progress": True,
                    "compiled_signature": sig,
                    "min_count": min_count,
                    "current_count": current,
                    "percent": final_percent,
                    # per-task aggregate block for DTO:
                    "aggregate": (
                        None
                        if not agg_spec
                        else {
                            "total": aggregate_total,
                            "target": aggregate_target or 0,
                            "unit": aggregate_unit or "points",
                        }
                    ),
                    "notes": notes,
                    "evaluated_in_ms": ms,
                    "last_evaluated_at": now(),
                    "updated_at": t.get("updated_at"),
                    "created_at": t.get("created_at"),
                }

        if snap["supported_for_progress"]:
            tasks_supported += 1
            sum_min += max(0, min_count)
            bounded_for_sum = (
                min(snap["current_count"], min_count) if min_count > 0 else snap["current_count"]
            )
            sum_current += bounded_for_sum
            if bounded_for_sum >= min_count and min_count > 0:
                tasks_done += 1

        snapshots.append(snap)

    aggregate_percent = (100.0 * (sum_current / sum_min)) if sum_min > 0 else 0.0
    aggregate_percent = round(aggregate_percent, 1)
    doc = {
        "user_challenge_id": uc_id,
        "checked_at": now(),
        "aggregate": {
            "percent": aggregate_percent,
            "tasks_done": tasks_done,
            "tasks_total": tasks_supported,
            "checked_at": now(),
        },
        "tasks": snapshots,
        "message": None,
        "created_at": now(),
    }
    if (uc_computed_status != "completed") and (tasks_done == tasks_supported):
        new_status = "completed"
        get_collection("user_challenges").update_one(
            {"_id": uc_id},
            {
                "$set": {
                    "computed_status": new_status,
                    "status": new_status,
                    "updated_at": utcnow(),
                }
            },
        )
    get_collection("progress").insert_one(doc)
    # enrich for response
    doc["id"] = str(doc.get("_id")) if "_id" in doc else None

    return doc


def get_latest_and_history(
    user_id: ObjectId,
    uc_id: ObjectId,
    limit: int = 10,
    before: datetime | None = None,
) -> dict[str, Any]:
    """Obtenir le dernier snapshot et un historique court.

    Description:
        R√©cup√®re jusqu‚Äô√† `limit` snapshots (tri desc), renvoie le plus r√©cent et un historique
        r√©sum√© (date + agr√©gat). `before` permet de paginer en arri√®re.

    Args:
        user_id (ObjectId): Utilisateur.
        uc_id (ObjectId): UserChallenge.
        limit (int): Taille max de l‚Äôhistorique (‚â•1).
        before (datetime | None): Curseur temporel exclusif.

    Returns:
        dict: `{'latest': dict | None, 'history': list[dict]}`.
    """
    q: dict[str, Any] = {}
    _ensure_uc_owned(user_id, uc_id)
    coll = get_collection("progress")
    q = {"user_challenge_id": uc_id}
    if before:
        q["checked_at"] = {"$lt": before}
    cur = coll.find(q).sort([("checked_at", DESCENDING)]).limit(limit)
    items = list(cur)
    latest = items[0] if items else None
    history = items[1:] if len(items) > 1 else []

    # --- enrichir 'latest' avec ETA par t√¢che + ETA globale ---
    if latest:
        # map (task_id -> {start_found_at, completed_at, min_count courant})
        tasks_coll = get_collection("user_challenge_tasks")
        tdocs = list(
            tasks_coll.find(
                {"user_challenge_id": uc_id},
                {"_id": 1, "start_found_at": 1, "completed_at": 1, "constraints": 1},
            )
        )
        dates_by_tid: dict[ObjectId, dict[str, Any]] = {
            d["_id"]: {
                "start": d.get("start_found_at"),
                "done": d.get("completed_at"),
                "min_count": int((d.get("constraints") or {}).get("min_count") or 0),
            }
            for d in tdocs
        }

        # calcule ETA par t√¢che du snapshot 'latest' en fonction d'aujourd'hui
        now_dt = now()
        eta_values: list[datetime] = []
        for it in latest.get("tasks") or []:
            tid = it.get("task_id")
            cur = int(it.get("current_count") or 0)
            # min_count : priorit√© au snapshot si pr√©sent, sinon doc task
            min_c = int(it.get("min_count") or dates_by_tid.get(tid, {}).get("min_count") or 0)
            info = dates_by_tid.get(tid) or {}
            start = info.get("start")
            done = info.get("done")

            eta = None
            if done:
                # termin√© -> ETA fig√©e
                # found_date est un 'date', on le normalise en 'datetime' pour la r√©ponse
                eta = datetime(done.year, done.month, done.day)  # 00:00 locale/UTC selon now()
            elif start and cur >= 1 and min_c > 0:
                # progression -> extrapolation
                # vitesse = (cur - 1) / jours √©coul√©s depuis la 1√®re trouvaille
                elapsed_days = max((now_dt.date() - start.date()).days, 1)
                speed = float(cur - 1) / float(elapsed_days)
                remaining = max(0, min_c - cur)
                if speed > 0.0 and remaining > 0:
                    eta_days = int(math.ceil(remaining / speed))
                    eta_date = now_dt.date() + timedelta(days=eta_days)
                    eta = datetime(eta_date.year, eta_date.month, eta_date.day)
                # sinon, eta = None

            # injecter l'ETA par t√¢che dans l'objet 'latest' (pour DTO)
            it["estimated_completion_at"] = eta

            if eta:
                eta_values.append(eta)

        # ETA globale = max des ETA non-None
        latest.setdefault("aggregate", {})
        latest["estimated_completion_at"] = max(eta_values) if eta_values else None

    def _summarize(d: dict[str, Any]) -> dict[str, Any]:
        return {
            "checked_at": d["checked_at"],
            "aggregate": d["aggregate"],
        }

    res = {
        "latest": latest,
        "history": [_summarize(h) for h in history],
    }
    if latest and "_id" in latest:
        latest["id"] = str(latest["_id"])
    return res


def evaluate_new_progress(
    user_id: ObjectId,
    *,
    include_pending: bool = False,
    limit: int = 50,
    since: datetime | None = None,
) -> dict[str, Any]:
    """√âvaluer un premier snapshot pour les UC sans progression.

    Description:
        S√©lectionne les UC de l‚Äôutilisateur avec statut `accepted` (et `pending` si demand√©),
        optionnellement cr√©√©s depuis `since`, **ignore** ceux ayant d√©j√† du `progress`,
        puis √©value jusqu‚Äô√† `limit` items.

    Args:
        user_id (ObjectId): Utilisateur.
        include_pending (bool): Inclure les UC `pending`.
        limit (int): Nombre max d‚ÄôUC √† traiter.
        since (datetime | None): Filtre de date de cr√©ation.

    Returns:
        dict: `{'evaluated_count': int, 'skipped_count': int, 'uc_ids': list[str]}`.
    """
    ucs = get_collection("user_challenges")
    progress = get_collection("progress")

    st = ["accepted"] + (["pending"] if include_pending else [])
    q: dict[str, Any] = {"user_id": user_id, "status": {"$in": st}}
    if since:
        q["created_at"] = {"$gte": since}

    # candidates
    cand = list(ucs.find(q, {"_id": 1}).sort([("_id", ASCENDING)]).limit(limit * 3))
    uc_ids = [c["_id"] for c in cand]

    # remove those already in progress
    if not uc_ids:
        return {"evaluated_count": 0, "skipped_count": 0, "uc_ids": []}
    present = set(
        d["user_challenge_id"]
        for d in progress.find({"user_challenge_id": {"$in": uc_ids}}, {"user_challenge_id": 1})
    )
    todo = [uc_id for uc_id in uc_ids if uc_id not in present][:limit]

    evaluated_ids: list[str] = []
    for uc_id in todo:
        evaluate_progress(user_id, uc_id)
        evaluated_ids.append(str(uc_id))

    return {
        "evaluated_count": len(evaluated_ids),
        "skipped_count": len(uc_ids) - len(evaluated_ids),
        "uc_ids": evaluated_ids,
    }
                            </pre>
                        </code>
                    </div>
                </dialog>
                <aside class="notes">
                    D√©normalisation pour all√®gement calculs<br>
                    Snapshots => s√©ries temporelles => projections + graphiques
                </aside>
            </section>

            <section>
                <h2>Autre composant ‚Äî Provider altim√©trie</h2>
                <ul>
                    <li class="fragment diapo__item">OpenTopoData : <span class="diapo__item__content">quotas,
                            rate-limiting, batch intelligent</span></li>
                    <li class="fragment diapo__item">Tol√©rance aux erreurs (None localis√©s), caching</li>
                </ul>
                <aside class="notes">
                    Batchs intelligents : minimiser nb requ√™tes / maximiser volume data par requ√™te
                </aside>
            </section>

            <section>
                <h2>S√©curit√© ‚Äî Authentification</h2>
                <ul>
                    <li class="fragment diapo__item">JWT + refresh tokens (rotation)</li>
                    <li class="fragment diapo__item">R√¥les user/admin</li>
                </ul>
                <aside class="notes">
                    Tokens : initial token + refresh token<br>
                    R√¥le user/admin : compartimentaliser les actions / r√¥le
                </aside>
            </section>

            <section>
                <h2>S√©curit√© ‚Äî Protection multicouche</h2>
                <ul>
                    <li class="fragment diapo__item">Validation Pydantic stricte</li>
                    <li class="fragment diapo__item">Sanitisation HTML (XSS), CORS</li>
                    <li class="fragment diapo__item">Rate limiting (client + OSM), isolation par utilisateur</li>
                </ul>
                <aside class="notes">
                    Python : pytest (unitaires), black (formateur automatique), mypy (v√©rif types statiques)<br>
                    Vue.js : lint + typecheck<br>
                    Rate limiting : protection logiciel + p√©rennit√© relations fournisseurs externes
                </aside>
            </section>

            <section>
                <h2>Plan de tests</h2>
                <ul>
                    <li class="fragment diapo__item">Pyramide : <span class="diapo__item__content">80% unit / 15% integ
                            / 5% E2E</span></li>
                    <li class="fragment diapo__item">Outils : <span class="diapo__item__content">Pytest / Vitest /
                            Playwright</span></li>
                    <li class="fragment diapo__item">Coverage vis√© : &gt;70%</li>
                </ul>
                <aside class="notes">
                    <a href="assets/20/pytest.png">Pytest</a><br>
                    <a href="assets/20/Vitest.png">Vitest</a><br>
                    <a href="assets/20/playwright.png">Playwright</a><br>
                    <a href="assets/20/coverage.png">Coverage</a>
                </aside>
            </section>

            <section>
                <h2>Jeu d‚Äôessai</h2>
                <ul>
                    <li class="fragment diapo__item">5 fichiers GPX (attendus vs obtenus)</li>
                    <li class="fragment diapo__item">Validation import, pays/r√©gions/challenges, 413 sur &gt;20Mo</li>
                </ul>
                <aside class="notes">
                    <a href="assets/21/jeu-essai.png">Jeu d'essai</a><br>
                    <a href="assets/21/import.png">Imoprt GPX</a>
                </aside>
            </section>

            <section>
                <h2>Veille vuln√©rabilit√©s</h2>
                <ul>
                    <li class="fragment diapo__item">CVE : <span class="diapo__item__content">suivi / proc√©dures
                            correctives</span></li>
                    <li class="fragment diapo__item">Audits s√©curit√© : <span class="diapo__item__content">pip-audit, npm
                            audit</span></li>
                    <li class="fragment diapo__item">Bonnes pratiques : <span class="diapo__item__content">defense in
                            depth, fail secure</span></li>
                </ul>
                <aside class="notes">
                    <a href="assets/22/cve.png">CVE</a><br>
                    <a href="assets/22/audits.png">Audits</a><br>
                    <a href="assets/22/bonnes-pratiques.png">Bonnes pratiques</a>
                </aside>
            </section>

            <section>
                <h2>Conclusion</h2>
                <ul>
                    <li class="fragment diapo__item">Comp√©tences CDA couvertes : <span class="diapo__item__content">3
                            blocs / 11 comp√©tences</span></li>
                    <li class="fragment diapo__item">Difficult√©s &amp; solutions, retours testeurs</li>
                    <li class="fragment diapo__item">Perspectives : <span class="diapo__item__content">offline,
                            application native, API Geocaching.com, IA ciblage</span></li>
                </ul>
                <aside class="notes">
                    <a href="assets/23/competences.png">Comp√©tences CDA</a><br>
                    <a href="assets/23/difficultes.png">Difficult√©s / Solutions / Retours</a>
                </aside>
            </section>

            <section>
                <h2>Merci / Questions</h2>
            </section>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@11.4.1/plugin/mermaid/mermaid.js"></script>
    <script type="module">
        //import RevealMermaid from "https://unpkg.com/reveal.js/plugin/mermaid/mermaid.esm.js";
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            transition: 'slide',     // request #1: movement (slide) instead of fade
            transitionSpeed: 'default',
            controls: true,
            progress: true,
            center: true,
            defaultTiming: 87,
            plugins: [RevealNotes, RevealMermaid],
            mermaid: { startOnLoad: true }
        });;
    </script>
    <script>
        // Version plus concise avec gestion d'erreur am√©lior√©e
        function initDialogTogglers() {
            document.querySelectorAll('.dialog_toggler').forEach(toggler => {
                toggler.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = toggler.getAttribute('href')?.replace('#', '');
                    const dialog = document.getElementById(targetId);

                    if (dialog?.tagName === 'DIALOG') {
                        // Ouvre le dialogue en mode plein √©cran
                        dialog.showModal();

                        // Ferme le dialogue au clic n'importe o√π
                        dialog.addEventListener('click', function closeOnClick(e) {
                            dialog.close();
                            // On retire l'event listener apr√®s fermeture
                            dialog.removeEventListener('click', closeOnClick);
                        });
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', initDialogTogglers);
    </script>
</body>

</html>